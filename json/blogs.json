{
    "blogs": [
        {
            "timestamp": 1642107198914,
            "tags": [],
            "name": "First Blog",
            "shortDesc": "Small write up on how my decision to write blogs and what I will write",
            "description": "<p>In this very first blog I wrote about what made me to finally start writting blogs. I also wrote about the steps to finally start writting blogs which is surprising very simple with services available today</p><!--<br>-->            <p>I also cannot wait to write more in the future</p>",
            "tileImageUrl": null,
            "galleryImgs": [],
            "videoUrl": null,
            "customLink": {
                "link": "https://blogs.jeslaspravin.com/general/2022/01/13/First-Blog/",
                "dispName": "Read More"
            },
            "gitLink": null
        },
        {
            "timestamp": 1644580800000,
            "tags": [
                "cranberry",
                "C++",
                "unicode",
                "utf",
                "encoding"
            ],
            "name": "Unicode and C++",
            "shortDesc": "Experience when converting ASCII string to UTF-8/16/32 string in my engine",
            "description": "<p>The blog provides some very basic explanation on Unicode and how I understood it in detail. I explained why I chose UTF-8 encoding for my engine</p><!--<br>--><p>I also wrote brief overview on UTF encodings and included source code of how I do conversions between various encodings. It also includes the encoding to codepoint conversion codes</p><!--<br>--><p>Some links to pages that helped me greatly when implementing this change is also included in the blog</p>",
            "tileImageUrl": "assets/unicodesTile.png",
            "galleryImgs": [
                {
                    "title": "",
                    "shortDesc": "",
                    "altDesc": "Generic image with several unicode characters in 2D different orientation",
                    "imgUrl": "assets/unicodes.png"
                }
            ],
            "videoUrl": null,
            "customLink": {
                "link": "https://blogs.jeslaspravin.com/cranberry/2022/02/11/Unicode-And-CPP/",
                "dispName": "Read More"
            },
            "gitLink": null
        },
        {
            "timestamp": 1696629600000,
            "tags": [
                "cranberry",
                "C++",
                "vulkan",
                "3d",
                "graphics",
                "rendering"
            ],
            "name": "Planning GAL",
            "shortDesc": "Blog about design plans and decision when creating the GAL for the Cranberry game engine",
            "description": "<p>I started planning the rework of the cranberry game engine's graphics API abstraction</p><!--<br>--><p>In this blog I write the decision I made when designing the initial portion of the Graphics Abstraction Layer(GAL)</p><!--<br>--><p>I will expand this page with additional planning as I progress through the implementations. For the actual implementation, I will try to blog it as separate pages.</p>",
            "tileImageUrl": "assets/genericPlanningTile.jpg",
            "galleryImgs": [
                {
                    "title": "",
                    "shortDesc": "",
                    "altDesc": "Generic image representing planning something",
                    "imgUrl": "assets/genericPlanning.jpg"
                }
            ],
            "videoUrl": null,
            "customLink": {
                "link": "https://blogs.jeslaspravin.com/cranberry/2023/10/06/Planning-GAL",
                "dispName": "Read More"
            },
            "gitLink": null
        },
        {
            "timestamp": 1705190400000,
            "tags": [
                "cranberry",
                "C++",
                "vulkan",
                "3d",
                "graphics",
                "rendering",
                "image",
                "buffer",
                "memory"
            ],
            "name": "GAL resource and memory",
            "shortDesc": "This post will cover how I am going to abstract the graphics layer for any resources(Images, Buffers) that require memory",
            "description": "<p>This post will cover how I am going to abstract the graphics layer for any resources(Images, Buffers) that require memory.<!--<br>-->The main point of interest/question I have right now is, How do I abstract the resource creation, memory allocation, and memory binding?<!--<br>-->Then there is sparse memory binding backed by hardware features. Which albeit slow right now, but worth considering.</p><!--<br>--><p>Summarizing the points/questions below : </p><!--<br>--><ul class=\"list-group\"><!--<br>--><li class=\"list-group-item mb-1 masked-bg-dark text-reset\">Should the abstraction layer allow creating resource and binding memory separately?</li><!--<br>--><li class=\"list-group-item mb-1 masked-bg-dark text-reset\">Should the abstraction layer allow the creation of resources with memory bound?</li><!--<br>--><li class=\"list-group-item mb-1 masked-bg-dark text-reset\">Should I start with sparse memory support from the start? If I do how does it work across different APIs?</li><!--<br>--><li class=\"list-group-item mb-1 masked-bg-dark text-reset\">Should the memory allocations be managed in the GAL layer? If yes should the memory management be implemented at the per-driver API level or GAL level inside GAL?</li><!--<br>--></ul>",
            "galleryImgs": [],
            "videoUrl": null,
            "customLink": {
                "link": "https://blogs.jeslaspravin.com/cranberry/2024/01/14/GAL-Resource-And-Memory/",
                "dispName": "Read More"
            },
            "gitLink": null
        },
        {
            "timestamp": 1706396400000,
            "tags": [
                "cranberry",
                "C++",
                "vulkan",
                "3d",
                "graphics",
                "rendering",
                "renderpass",
                "framebuffer",
                "pipeline",
                "compute",
                "shader",
                "compiler"
            ],
            "name": "GAL render pass, framebuffer, pipelines and descriptors",
            "shortDesc": "Managing compatibility between render passes, pipelines, and framebuffers. Also future plans for GAL user layer, GAL helper libraries",
            "description": "<p>Managing compatibility between render passes, pipelines, and framebuffers can be challenging. Creating a descriptor layout and using it to create pipelines can also be difficult. Allocating descriptors from the descriptor pool and ensuring that they are fully compatible with the pipeline can be another challenge. Supporting additional features like bindless and buffer memory addressing can further complicate the process.</p><!--<br>--><p>A nice image depicting the relation between various vulkan objects. Answers, how to handle this level of complexity?</p><!--<br>--><p>Has some write ups of following topics:</p><!--<br>--><ul class=\"list-group\"><!--<br>--><li class=\"list-group-item mb-1 masked-bg-dark text-reset\">Render pass</li><!--<br>--><li class=\"list-group-item mb-1 masked-bg-dark text-reset\">Framebuffer</li><!--<br>--><li class=\"list-group-item mb-1 masked-bg-dark text-reset\">Pipeline layout and Descriptors sets</li><!--<br>--><li class=\"list-group-item mb-1 masked-bg-dark text-reset\">Framebuffer attachments</li><!--<br>--><li class=\"list-group-item mb-1 masked-bg-dark text-reset\">Pipelines</li><!--<br>--><li class=\"list-group-item mb-1 masked-bg-dark text-reset\">Shader compiler</li><!--<br>--><li class=\"list-group-item mb-1 masked-bg-dark text-reset\">GAL helper libraries</li><!--<br>--></ul>",
            "tileImageUrl": "https://blogs.jeslaspravin.com/assets/images/CranberryEngine/GAL-RP-Pipe-FB-DescSet.svg",
            "galleryImgs": [
                {
                    "title": "",
                    "shortDesc": "",
                    "altDesc": "Entity relation diagram of Renderpass, Pipeline, Framebuffer, Descriptors",
                    "imgUrl": "https://blogs.jeslaspravin.com/assets/images/CranberryEngine/GAL-RP-Pipe-FB-DescSet.svg"
                }
            ],
            "videoUrl": null,
            "customLink": {
                "link": "https://blogs.jeslaspravin.com/cranberry/2024/01/27/GAL-RenderPass-Framebuffer-Pipelines-Descriptors/",
                "dispName": "Read More"
            },
            "gitLink": null
        },
        {
            "timestamp": 1708732800000,
            "tags": [
                "cranberry",
                "C++",
                "compiler",
                "language",
                "shader",
                "hlsl",
                "spirv",
                "reflection",
                "gpu",
                "program",
                "engine"
            ],
            "name": "Shader compiler",
            "shortDesc": "Designing the shader compiler to work with engine shaders both offline and runtime",
            "description": "<p>The blog about design and decisions I took for the shader compiler of my Engine</p><!--<br>--><p>I need a shader compiler to parse the shader files and generate the shader byte code necessary for appropriate graphics API being used. The compiler must also be able to generate necessary reflection files. I am going to use DXC to compile shaders. For Vulkan api DXC will be able to cross compile and generate SPIRV bytecodes. SPIRV-Cross can be used to generate reflection out of SPIRV bytecode. I hope the reflections from DXC and SPIRV can be used together to generate as much reflection information as possible.</p><!--<br>--><p>Features:</p><!--<br>--><ul class=\"list-group\"><!--<br>--><li class=\"list-group-item mb-1 masked-bg-dark text-reset\">Highly multithreaded</li><!--<br>--><li class=\"list-group-item mb-1 masked-bg-dark text-reset\">Separate Job system from main job system, uses inter job system job transfers feature.</li><!--<br>--><li class=\"list-group-item mb-1 masked-bg-dark text-reset\">SPIRV optimizer as post process to control optimization</li><!--<br>--><li class=\"list-group-item mb-1 masked-bg-dark text-reset\">Shader reflection</li><!--<br>--><li class=\"list-group-item mb-1 masked-bg-dark text-reset\">Works as other piece of GAL to generate data that requires minimal change for renderer usage</li><!--<br>--><li class=\"list-group-item mb-1 masked-bg-dark text-reset\">Generate permutations with callback base code generation customization. Used for Material system specific code gen.</li><!--<br>--></ul>",
            "tileImageUrl": "https://blogs.jeslaspravin.com/assets/images/CranberryEngine/ShaderCompiler.svg",
            "galleryImgs": [],
            "videoUrl": null,
            "customLink": {
                "link": "https://blogs.jeslaspravin.com/cranberry/2024/02/03/ShaderCompiler/",
                "dispName": "Read More"
            },
            "gitLink": null
        },
        {
            "timestamp": 1709420400000,
            "tags": [
                "cranberry",
                "C++",
                "token",
                "compiler",
                "language",
                "json",
                "toml",
                "config",
                "data"
            ],
            "name": "Basic tokenizer",
            "shortDesc": "Basic tokens parser helper functions",
            "description": "<p>The tokenizer that I am about to create will contained inside a parser helper class. This is the first version of general purpose tokenizer. It is created to allow parsing my custom text based config format.</p><!--<br>--><p>This blog writes up some insight behind the decisions I made. It might be incorrect choice but these are the current decision.</p><!--<br>--><p>Some features to be included in this intial version:</p><!--<br>--><ul class=\"list-group\"><!--<br>--><li class=\"list-group-item mb-1 masked-bg-dark text-reset\">Multipass</li><!--<br>--><li class=\"list-group-item mb-1 masked-bg-dark text-reset\">Running a pass is caller's choice</li><!--<br>--></ul>",
            "tileImageUrl": "https://blogs.jeslaspravin.com/assets/images/CranberryEngine/compiler_tokenizer_cartoon.jpg",
            "galleryImgs": [],
            "videoUrl": null,
            "customLink": {
                "link": "https://blogs.jeslaspravin.com/cranberry/2024/03/03/Basic-Tokenizer/",
                "dispName": "Read More"
            },
            "gitLink": null
        },
        {
            "timestamp": 1729814400000,
            "tags": [
                "cranberry",
                "C++",
                "renderer",
                "scene",
                "world",
                "transfer",
                "gpu",
                "engine"
            ],
            "name": "World Renderer",
            "shortDesc": "Design of Cranberry's main world renderer",
            "description": "<p>The blog about design and decisions I took for main world renderer of my Engine</p><!--<br>--><p></p><!--<br>--><p>Features:</p><!--<br>--><ul class=\"list-group\"><!--<br>--><li class=\"list-group-item mb-1 masked-bg-dark text-reset\">Async compute</li><!--<br>--><li class=\"list-group-item mb-1 masked-bg-dark text-reset\">Async transfer</li><!--<br>--><li class=\"list-group-item mb-1 masked-bg-dark text-reset\">GPU driven</li><!--<br>--><li class=\"list-group-item mb-1 masked-bg-dark text-reset\">Bindless</li><!--<br>--><li class=\"list-group-item mb-1 masked-bg-dark text-reset\">Indirect draw calls</li><!--<br>--><li class=\"list-group-item mb-1 masked-bg-dark text-reset\">Compute frustum culling</li><!--<br>--></ul>",
            "tileImageUrl": "https://blogs.jeslaspravin.com/assets/images/CranberryEngine/WorldRenderer.jpg",
            "galleryImgs": [],
            "videoUrl": null,
            "customLink": {
                "link": "https://blogs.jeslaspravin.com/cranberry/2024/09/07/Cranberry-Renderer/",
                "dispName": "Read More"
            },
            "gitLink": null
        }
    ]
}